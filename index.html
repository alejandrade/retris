<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Retris - A Tetris Game Built with Rust</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #0d0d14;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        canvas {
            display: block;
            image-rendering: pixelated;

            /* ADD THESE THREE LINES */
            touch-action: none; /* Stops the iPhone from scrolling/zooming */
            user-select: none; /* Stops the "copy/paste" loupe from appearing */
            -webkit-user-select: none;
            outline: none; /* Removes the focus ring */
        }

        #start-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: white;
            font-family: monospace;
        }

        #start-overlay.hidden {
            display: none;
        }

        #dpi-display {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 24px;
            font-weight: bold;
            padding: 12px 24px;
            border: 2px solid #00ff00;
            border-radius: 8px;
            z-index: 2000;
            pointer-events: none;
            user-select: none;
            -webkit-user-select: none;
            box-shadow: 0 4px 12px rgba(0, 255, 0, 0.3);
        }
    </style>
</head>
<body>

<div id="start-overlay">
    <div id="start-overlay-content">
        <h1>RETRIS</h1>
        <p>Click to Start</p>
    </div>
</div>

<div id="dpi-display">DPI: 1.0x</div>

<script>
    const overlay = document.getElementById('start-overlay');
    let startMusicFn = null;
    let retryCount = 0;
    const MAX_RETRIES = 50;

    /**
     * DPI & RESIZING LOGIC
     */
    let lastKnownDPR = window.devicePixelRatio || 1.0;

    function updateDPIDisplay() {
        const dpiDisplay = document.getElementById('dpi-display');
        if (dpiDisplay && dpiDisplay.style.display !== 'none') {
            const dpr = window.devicePixelRatio || 1.0;
            dpiDisplay.textContent = `DPI: ${dpr.toFixed(2)}x`;
        }
    }

    function syncDPIAndResize() {
        const canvas = document.querySelector('canvas');
        if (!canvas) return;

        const dpr = window.devicePixelRatio || 1.0;
        const dprChanged = dpr !== lastKnownDPR;

        // Update DPI display
        updateDPIDisplay();

        // Update last known DPR
        if (dprChanged) {
            console.log(`DPI changed from ${lastKnownDPR}x to ${dpr}x`);
            lastKnownDPR = dpr;
        }

        // Calculate Visual (CSS) Size based on Aspect Ratio
        const TARGET_RATIO = 10 / 20; // Classic Tetris
        let visualWidth = window.innerWidth;
        let visualHeight = window.innerHeight;

        if (visualWidth / visualHeight > TARGET_RATIO) {
            visualWidth = visualHeight * TARGET_RATIO;
        } else {
            visualHeight = visualWidth / TARGET_RATIO;
        }

        // Set Internal Buffer Size (Physical Pixels)
        // Note: Rust side (egor_render) will clamp this to safe limits
        canvas.width = Math.floor(visualWidth * dpr);
        canvas.height = Math.floor(visualHeight * dpr);

        // Set Visual Size (CSS Pixels) - this stretches the buffer to fill screen
        canvas.style.width = `${visualWidth}px`;
        canvas.style.height = `${visualHeight}px`;

        console.log(`Resize: DPI=${dpr}x | Buffer=${canvas.width}x${canvas.height} | CSS=${visualWidth}x${visualHeight}`);
    }

    // Listen for window resize
    window.addEventListener('resize', syncDPIAndResize);

    // Continuous DPI monitoring (for moving between monitors with different DPI)
    // Check for DPI changes periodically
    let dpiCheckInterval = setInterval(() => {
        const currentDPR = window.devicePixelRatio || 1.0;
        if (currentDPR !== lastKnownDPR) {
            syncDPIAndResize();
        } else {
            // Update display even if DPR hasn't changed (in case of resize)
            updateDPIDisplay();
        }
    }, 250); // Check every 250ms

    // Also use matchMedia for DPI change detection (more efficient when supported)
    // Create a media query for the current DPI
    function setupDPIChangeListener() {
        const currentDPR = window.devicePixelRatio || 1.0;
        const mediaQuery = window.matchMedia(`(resolution: ${currentDPR}dppx)`);
        
        const handleDPIChange = (e) => {
            if (!e.matches) {
                // DPI changed, update immediately
                syncDPIAndResize();
                // Re-setup listener for new DPI
                setupDPIChangeListener();
            }
        };
        
        // Remove old listener if it exists
        if (mediaQuery.removeEventListener) {
            mediaQuery.removeEventListener('change', handleDPIChange);
        }
        
        // Add new listener
        if (mediaQuery.addEventListener) {
            mediaQuery.addEventListener('change', handleDPIChange);
        } else {
            // Fallback for older browsers
            mediaQuery.addListener(handleDPIChange);
        }
    }
    
    // Setup initial DPI change listener
    setupDPIChangeListener();

    /**
     * WASM INITIALIZATION
     */
    function initializeWasmHooks() {
        if (window.wasmBindings) {
            syncDPIAndResize();
            findAndCacheMusic();

            // Check debug mode and hide DPI display if debug is disabled
            if (window.wasmBindings.is_debug_enabled && !window.wasmBindings.is_debug_enabled()) {
                const dpiDisplay = document.getElementById('dpi-display');
                if (dpiDisplay) {
                    dpiDisplay.style.display = 'none';
                }
            }
        } else if (retryCount < MAX_RETRIES) {
            retryCount++;
            setTimeout(initializeWasmHooks, 100);
        }
    }

    function findAndCacheMusic() {
        if (window.wasmBindings?.start_music) {
            startMusicFn = window.wasmBindings.start_music;
        }
    }

    /**
     * INTERACTION HANDLERS
     */
    overlay.addEventListener('click', () => {
        overlay.classList.add('hidden');

        // Ensure we have the latest music function
        findAndCacheMusic();
        if (startMusicFn) startMusicFn();

        // Focus the canvas for keyboard input
        const canvas = document.querySelector('canvas');
        if (canvas) {
            canvas.setAttribute('tabindex', '0');
            canvas.focus();
        }
    });

    // Start polling on load
    window.addEventListener('load', () => {
        initializeWasmHooks();
        updateDPIDisplay(); // Initialize DPI display
    });

    // Initial canvas detection loop
    const detectionInterval = setInterval(() => {
        if (document.querySelector('canvas')) {
            syncDPIAndResize();
            clearInterval(detectionInterval);
        }
    }, 100);

</script>
</body>
</html>