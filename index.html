<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Retris - A Tetris Game Built with Rust</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #0d0d14;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        canvas {
            display: block;
            image-rendering: pixelated;

            /* ADD THESE THREE LINES */
            touch-action: none; /* Stops the iPhone from scrolling/zooming */
            user-select: none; /* Stops the "copy/paste" loupe from appearing */
            -webkit-user-select: none;
            outline: none; /* Removes the focus ring */
        }

        #start-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: white;
            font-family: monospace;
        }

        #start-overlay.hidden {
            display: none;
        }
    </style>
</head>
<body>

<div id="start-overlay">
    <div id="start-overlay-content">
        <h1>RETRIS</h1>
        <p>Click to Start</p>
    </div>
</div>

<script>
    const overlay = document.getElementById('start-overlay');
    let startMusicFn = null;
    let retryCount = 0;
    const MAX_RETRIES = 50;

    /**
     * DPI & RESIZING LOGIC
     */
    let lastKnownDPR = window.devicePixelRatio || 1.0;

    function syncDPIAndResize() {
        const canvas = document.querySelector('canvas');
        if (!canvas) return;

        const dpr = window.devicePixelRatio || 1.0;
        const dprChanged = dpr !== lastKnownDPR;

        // 1. Send DPR to WASM if binding is ready (especially if DPR changed)
        if (window.wasmBindings && window.wasmBindings.set_device_pixel_ratio) {
            window.wasmBindings.set_device_pixel_ratio(dpr);
            if (dprChanged) {
                console.log(`DPI changed from ${lastKnownDPR}x to ${dpr}x - WASM updated`);
            }
        }

        // Update last known DPR
        lastKnownDPR = dpr;

        // 2. Calculate Visual (CSS) Size based on Aspect Ratio
        const TARGET_RATIO = 10 / 20; // Classic Tetris
        let visualWidth = window.innerWidth;
        let visualHeight = window.innerHeight;

        if (visualWidth / visualHeight > TARGET_RATIO) {
            visualWidth = visualHeight * TARGET_RATIO;
        } else {
            visualHeight = visualWidth / TARGET_RATIO;
        }

        // 3. Set Internal Buffer Size (Physical Pixels)
        // This is the "Magic Equation" for high-DPI
        canvas.width = Math.floor(visualWidth * dpr);
        canvas.height = Math.floor(visualHeight * dpr);

        // 4. Set Visual Size (CSS Pixels)
        canvas.style.width = `${visualWidth}px`;
        canvas.style.height = `${visualHeight}px`;

        console.log(`DPI Sync: ${dpr}x | Buffer: ${canvas.width}x${canvas.height}`);
    }

    // Listen for window resize
    window.addEventListener('resize', syncDPIAndResize);

    // Continuous DPI monitoring (for moving between monitors with different DPI)
    // Check for DPI changes periodically
    let dpiCheckInterval = setInterval(() => {
        const currentDPR = window.devicePixelRatio || 1.0;
        if (currentDPR !== lastKnownDPR) {
            syncDPIAndResize();
        }
    }, 250); // Check every 250ms

    // Also use matchMedia for DPI change detection (more efficient when supported)
    // Create a media query for the current DPI
    function setupDPIChangeListener() {
        const currentDPR = window.devicePixelRatio || 1.0;
        const mediaQuery = window.matchMedia(`(resolution: ${currentDPR}dppx)`);
        
        const handleDPIChange = (e) => {
            if (!e.matches) {
                // DPI changed, update immediately
                syncDPIAndResize();
                // Re-setup listener for new DPI
                setupDPIChangeListener();
            }
        };
        
        // Remove old listener if it exists
        if (mediaQuery.removeEventListener) {
            mediaQuery.removeEventListener('change', handleDPIChange);
        }
        
        // Add new listener
        if (mediaQuery.addEventListener) {
            mediaQuery.addEventListener('change', handleDPIChange);
        } else {
            // Fallback for older browsers
            mediaQuery.addListener(handleDPIChange);
        }
    }
    
    // Setup initial DPI change listener
    setupDPIChangeListener();

    /**
     * WASM INITIALIZATION
     */
    function initializeWasmHooks() {
        if (window.wasmBindings && window.wasmBindings.set_device_pixel_ratio) {
            syncDPIAndResize();
            findAndCacheMusic();
        } else if (retryCount < MAX_RETRIES) {
            retryCount++;
            setTimeout(initializeWasmHooks, 100);
        }
    }

    function findAndCacheMusic() {
        if (window.wasmBindings?.start_music) {
            startMusicFn = window.wasmBindings.start_music;
        }
    }

    /**
     * INTERACTION HANDLERS
     */
    overlay.addEventListener('click', () => {
        overlay.classList.add('hidden');

        // Ensure we have the latest music function
        findAndCacheMusic();
        if (startMusicFn) startMusicFn();

        // Focus the canvas for keyboard input
        const canvas = document.querySelector('canvas');
        if (canvas) {
            canvas.setAttribute('tabindex', '0');
            canvas.focus();
        }
    });

    // Start polling on load
    window.addEventListener('load', initializeWasmHooks);

    // Initial canvas detection loop
    const detectionInterval = setInterval(() => {
        if (document.querySelector('canvas')) {
            syncDPIAndResize();
            clearInterval(detectionInterval);
        }
    }, 100);

</script>
</body>
</html>